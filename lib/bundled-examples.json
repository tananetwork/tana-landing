[
  {
    "id": "hello-world",
    "title": "Hello World",
    "description": "Basic smart contract that stores and retrieves a greeting message",
    "category": "Basic",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('greeting', 'Hello, Tana!')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (!input.greeting) {\n    throw new Error('Greeting required')\n  }\n\n  await kv.put('greeting', input.greeting)\n  await kv.put('lastUpdatedBy', caller.id)\n\n  return { success: true, greeting: input.greeting }\n}\n\nexport async function get(req: Request) {\n  const greeting = await kv.get('greeting')\n  const lastUpdatedBy = await kv.get('lastUpdatedBy')\n\n  return { greeting, lastUpdatedBy }\n}",
    "result": {
      "greeting": "Hello, Tana!",
      "lastUpdatedBy": "usr_abc123"
    }
  },
  {
    "id": "counter",
    "title": "Counter",
    "description": "Simple counter that can be incremented and decremented",
    "category": "Basic",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('count', '0')\n  return { initialized: true, count: 0 }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const count = parseInt(await kv.get('count') || '0')\n\n  let newCount = count\n\n  if (input.action === 'increment') {\n    newCount = count + (input.amount || 1)\n  } else if (input.action === 'decrement') {\n    newCount = count - (input.amount || 1)\n  } else if (input.action === 'reset') {\n    newCount = 0\n  }\n\n  await kv.put('count', String(newCount))\n\n  return {\n    success: true,\n    action: input.action,\n    previousCount: count,\n    currentCount: newCount\n  }\n}\n\nexport async function get(req: Request) {\n  const count = parseInt(await kv.get('count') || '0')\n  return { count }\n}",
    "result": {
      "success": true,
      "action": "increment",
      "previousCount": 5,
      "currentCount": 6
    }
  },
  {
    "id": "key-value-store",
    "title": "Key-Value Store",
    "description": "Generic key-value storage with permissions",
    "category": "Basic",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const owner = context.owner()\n  await kv.put('_owner', owner.id)\n  return { initialized: true, owner: owner.username }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n  const owner = await kv.get('_owner')\n\n  // Only owner can write\n  if (caller.id !== owner) {\n    throw new Error('Unauthorized')\n  }\n\n  if (input.action === 'set') {\n    await kv.put(input.key, input.value)\n    return { success: true, key: input.key, value: input.value }\n  }\n\n  if (input.action === 'delete') {\n    await kv.delete(input.key)\n    return { success: true, deleted: input.key }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const key = url.searchParams.get('key')\n\n  if (!key) {\n    // List all keys\n    const list = await kv.list()\n    return { keys: list.keys.filter(k => !k.name.startsWith('_')) }\n  }\n\n  const value = await kv.get(key)\n  return { key, value }\n}",
    "result": {
      "success": true,
      "key": "config",
      "value": "enabled"
    }
  },
  {
    "id": "token-system",
    "title": "Token System",
    "description": "Full-featured token with minting, transfers, and allowances",
    "category": "Finance",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const owner = context.owner()\n  const input = context.input()\n\n  await kv.put('name', input.name || 'MyToken')\n  await kv.put('symbol', input.symbol || 'MTK')\n  await kv.put('totalSupply', '0')\n  await kv.put('owner', owner.id)\n\n  return { initialized: true, name: input.name, symbol: input.symbol }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (input.action === 'mint') {\n    const owner = await kv.get('owner')\n    if (caller.id !== owner) throw new Error('Only owner can mint')\n\n    const balance = parseInt(await kv.get(`balance:${input.to}`) || '0')\n    const totalSupply = parseInt(await kv.get('totalSupply') || '0')\n\n    await kv.put(`balance:${input.to}`, String(balance + input.amount))\n    await kv.put('totalSupply', String(totalSupply + input.amount))\n\n    return { success: true, minted: input.amount, to: input.to }\n  }\n\n  if (input.action === 'transfer') {\n    const fromBalance = parseInt(await kv.get(`balance:${caller.id}`) || '0')\n    const toBalance = parseInt(await kv.get(`balance:${input.to}`) || '0')\n\n    if (fromBalance < input.amount) throw new Error('Insufficient balance')\n\n    await kv.put(`balance:${caller.id}`, String(fromBalance - input.amount))\n    await kv.put(`balance:${input.to}`, String(toBalance + input.amount))\n\n    return { success: true, from: caller.id, to: input.to, amount: input.amount }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const address = url.searchParams.get('address')\n\n  if (!address) {\n    return {\n      name: await kv.get('name'),\n      symbol: await kv.get('symbol'),\n      totalSupply: await kv.get('totalSupply')\n    }\n  }\n\n  const balance = await kv.get(`balance:${address}`) || '0'\n  return { address, balance: parseInt(balance) }\n}",
    "result": {
      "success": true,
      "from": "usr_alice",
      "to": "usr_bob",
      "amount": 100
    }
  },
  {
    "id": "escrow",
    "title": "Escrow Contract",
    "description": "Hold funds until conditions are met with arbiter",
    "category": "Finance",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const input = context.input()\n  const owner = context.owner()\n\n  await kv.put('buyer', input.buyer)\n  await kv.put('seller', input.seller)\n  await kv.put('amount', input.amount)\n  await kv.put('status', 'pending')\n  await kv.put('arbiter', owner.id)\n\n  return { initialized: true, buyer: input.buyer, seller: input.seller }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  const buyer = await kv.get('buyer')\n  const seller = await kv.get('seller')\n  const arbiter = await kv.get('arbiter')\n  const status = await kv.get('status')\n\n  if (status !== 'pending') {\n    throw new Error('Escrow already completed')\n  }\n\n  if (input.action === 'release' && caller.id === arbiter) {\n    await kv.put('status', 'released')\n    return { success: true, action: 'released', to: seller }\n  }\n\n  if (input.action === 'refund' && caller.id === arbiter) {\n    await kv.put('status', 'refunded')\n    return { success: true, action: 'refunded', to: buyer }\n  }\n\n  throw new Error('Unauthorized or invalid action')\n}\n\nexport async function get(req: Request) {\n  return {\n    buyer: await kv.get('buyer'),\n    seller: await kv.get('seller'),\n    amount: await kv.get('amount'),\n    status: await kv.get('status'),\n    arbiter: await kv.get('arbiter')\n  }\n}",
    "result": {
      "success": true,
      "action": "released",
      "to": "usr_seller123"
    }
  },
  {
    "id": "crowdfunding",
    "title": "Crowdfunding Campaign",
    "description": "Raise funds with goal and deadline",
    "category": "Finance",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const input = context.input()\n  const owner = context.owner()\n\n  await kv.put('creator', owner.id)\n  await kv.put('goal', input.goal)\n  await kv.put('deadline', input.deadline)\n  await kv.put('raised', '0')\n  await kv.put('status', 'active')\n\n  return { initialized: true, goal: input.goal, deadline: input.deadline }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n  const now = Date.now()\n\n  const deadline = parseInt(await kv.get('deadline'))\n  const status = await kv.get('status')\n\n  if (input.action === 'contribute') {\n    if (now > deadline || status !== 'active') {\n      throw new Error('Campaign ended')\n    }\n\n    const raised = parseInt(await kv.get('raised') || '0')\n    const userContribution = parseInt(await kv.get(`contribution:${caller.id}`) || '0')\n\n    await kv.put('raised', String(raised + input.amount))\n    await kv.put(`contribution:${caller.id}`, String(userContribution + input.amount))\n\n    return { success: true, contributed: input.amount, totalRaised: raised + input.amount }\n  }\n\n  if (input.action === 'finalize') {\n    const creator = await kv.get('creator')\n    if (caller.id !== creator) throw new Error('Only creator can finalize')\n\n    const raised = parseInt(await kv.get('raised'))\n    const goal = parseInt(await kv.get('goal'))\n\n    if (raised >= goal) {\n      await kv.put('status', 'successful')\n      return { success: true, status: 'successful', raised }\n    } else {\n      await kv.put('status', 'failed')\n      return { success: true, status: 'failed', raised }\n    }\n  }\n}\n\nexport async function get(req: Request) {\n  return {\n    goal: await kv.get('goal'),\n    raised: await kv.get('raised'),\n    deadline: await kv.get('deadline'),\n    status: await kv.get('status'),\n    creator: await kv.get('creator')\n  }\n}",
    "result": {
      "success": true,
      "contributed": 50,
      "totalRaised": 450
    }
  },
  {
    "id": "voting-poll",
    "title": "Voting Poll",
    "description": "Create polls and vote on multiple options",
    "category": "Governance",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const input = context.input()\n\n  await kv.put('question', input.question)\n  await kv.put('options', JSON.stringify(input.options))\n  await kv.put('votes', JSON.stringify({}))\n  await kv.put('endTime', input.endTime || String(Date.now() + 86400000))\n\n  return { initialized: true, question: input.question, options: input.options }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  const endTime = parseInt(await kv.get('endTime'))\n  if (Date.now() > endTime) {\n    throw new Error('Poll ended')\n  }\n\n  const votes = JSON.parse(await kv.get('votes') || '{}')\n\n  if (votes[caller.id]) {\n    throw new Error('Already voted')\n  }\n\n  votes[caller.id] = input.option\n  await kv.put('votes', JSON.stringify(votes))\n\n  return { success: true, voted: input.option, totalVotes: Object.keys(votes).length }\n}\n\nexport async function get(req: Request) {\n  const question = await kv.get('question')\n  const options = JSON.parse(await kv.get('options') || '[]')\n  const votes = JSON.parse(await kv.get('votes') || '{}')\n  const endTime = await kv.get('endTime')\n\n  const results: Record<string, number> = {}\n  for (const vote of Object.values(votes)) {\n    results[vote as string] = (results[vote as string] || 0) + 1\n  }\n\n  return {\n    question,\n    options,\n    results,\n    totalVotes: Object.keys(votes).length,\n    endTime: parseInt(endTime),\n    hasEnded: Date.now() > parseInt(endTime)\n  }\n}",
    "result": {
      "success": true,
      "voted": "Option A",
      "totalVotes": 15
    }
  },
  {
    "id": "dao-governance",
    "title": "DAO Governance",
    "description": "Token-weighted voting for DAOs",
    "category": "Governance",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport { block } from 'tana/block'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const input = context.input()\n  await kv.put('proposalCount', '0')\n  await kv.put('quorum', input.quorum || '1000')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (input.action === 'propose') {\n    const count = parseInt(await kv.get('proposalCount') || '0')\n    const proposalId = `prop_${count + 1}`\n\n    await kv.put(proposalId, JSON.stringify({\n      title: input.title,\n      description: input.description,\n      proposer: caller.id,\n      created: Date.now(),\n      votes: { for: 0, against: 0 },\n      status: 'active'\n    }))\n\n    await kv.put('proposalCount', String(count + 1))\n    return { success: true, proposalId }\n  }\n\n  if (input.action === 'vote') {\n    const proposal = JSON.parse(await kv.get(input.proposalId))\n    if (proposal.status !== 'active') throw new Error('Proposal not active')\n\n    // Check if already voted\n    const voteKey = `vote:${input.proposalId}:${caller.id}`\n    if (await kv.get(voteKey)) throw new Error('Already voted')\n\n    // Get voter's token balance (simplified)\n    const balance = await block.getBalance(caller.id, 'GOV')\n    const weight = balance?.amount || 1\n\n    if (input.vote === 'for') {\n      proposal.votes.for += weight\n    } else {\n      proposal.votes.against += weight\n    }\n\n    await kv.put(input.proposalId, JSON.stringify(proposal))\n    await kv.put(voteKey, input.vote)\n\n    return { success: true, voted: input.vote, weight }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const proposalId = url.searchParams.get('id')\n\n  if (proposalId) {\n    const proposal = await kv.get(proposalId)\n    return proposal ? JSON.parse(proposal) : null\n  }\n\n  const count = await kv.get('proposalCount') || '0'\n  return { proposalCount: parseInt(count) }\n}",
    "result": {
      "success": true,
      "voted": "for",
      "weight": 100
    }
  },
  {
    "id": "user-registry",
    "title": "User Registry",
    "description": "Register users with profile information",
    "category": "Identity",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('userCount', '0')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  const existing = await kv.get(`user:${caller.id}`)\n  if (existing) {\n    throw new Error('Already registered')\n  }\n\n  if (!input.username || !input.bio) {\n    throw new Error('Username and bio required')\n  }\n\n  const profile = {\n    username: input.username,\n    bio: input.bio,\n    joinedAt: Date.now()\n  }\n\n  await kv.put(`user:${caller.id}`, JSON.stringify(profile))\n\n  const count = parseInt(await kv.get('userCount') || '0')\n  await kv.put('userCount', String(count + 1))\n\n  return { success: true, profile }\n}\n\nexport async function get(req: Request) {\n  const userId = req.tana.caller?.id\n  if (!userId) {\n    return { error: 'Authentication required' }\n  }\n\n  const profile = await kv.get(`user:${userId}`)\n  const userCount = await kv.get('userCount')\n\n  return {\n    profile: profile ? JSON.parse(profile) : null,\n    totalUsers: parseInt(userCount || '0')\n  }\n}",
    "result": {
      "success": true,
      "profile": {
        "username": "alice",
        "bio": "Developer",
        "joinedAt": 1699564800000
      }
    }
  },
  {
    "id": "reputation-system",
    "title": "Reputation System",
    "description": "Track user reputation with endorsements",
    "category": "Identity",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (input.action === 'endorse') {\n    const target = input.userId\n    const endorseKey = `endorse:${caller.id}:${target}`\n\n    if (await kv.get(endorseKey)) {\n      throw new Error('Already endorsed this user')\n    }\n\n    const score = parseInt(await kv.get(`reputation:${target}`) || '0')\n    await kv.put(`reputation:${target}`, String(score + input.points))\n    await kv.put(endorseKey, 'true')\n\n    return { success: true, userId: target, newScore: score + input.points }\n  }\n\n  if (input.action === 'badge') {\n    const badges = JSON.parse(await kv.get(`badges:${input.userId}`) || '[]')\n    badges.push({\n      name: input.badge,\n      issuedBy: caller.id,\n      issuedAt: Date.now()\n    })\n    await kv.put(`badges:${input.userId}`, JSON.stringify(badges))\n\n    return { success: true, badge: input.badge, userId: input.userId }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const userId = url.searchParams.get('userId')\n\n  if (!userId) {\n    return { error: 'userId required' }\n  }\n\n  const reputation = parseInt(await kv.get(`reputation:${userId}`) || '0')\n  const badges = JSON.parse(await kv.get(`badges:${userId}`) || '[]')\n\n  return { userId, reputation, badges }\n}",
    "result": {
      "success": true,
      "userId": "usr_alice",
      "newScore": 150
    }
  },
  {
    "id": "leaderboard",
    "title": "Leaderboard",
    "description": "Track high scores and rankings",
    "category": "Gaming",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('scores', JSON.stringify([]))\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  const scores = JSON.parse(await kv.get('scores') || '[]')\n\n  const entry = {\n    userId: caller.id,\n    username: caller.username,\n    score: input.score,\n    timestamp: Date.now()\n  }\n\n  scores.push(entry)\n  scores.sort((a, b) => b.score - a.score)\n\n  // Keep top 100\n  const top100 = scores.slice(0, 100)\n  await kv.put('scores', JSON.stringify(top100))\n\n  const rank = top100.findIndex(s => s.userId === caller.id && s.score === input.score) + 1\n\n  return {\n    success: true,\n    score: input.score,\n    rank,\n    isTopScore: rank === 1\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const limit = parseInt(url.searchParams.get('limit') || '10')\n\n  const scores = JSON.parse(await kv.get('scores') || '[]')\n\n  return {\n    topScores: scores.slice(0, limit),\n    totalEntries: scores.length\n  }\n}",
    "result": {
      "success": true,
      "score": 9500,
      "rank": 3,
      "isTopScore": false
    }
  },
  {
    "id": "nft-marketplace",
    "title": "NFT Marketplace",
    "description": "List and trade digital items",
    "category": "Marketplace",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('listingCount', '0')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (input.action === 'list') {\n    const count = parseInt(await kv.get('listingCount') || '0')\n    const listingId = `listing_${count + 1}`\n\n    await kv.put(listingId, JSON.stringify({\n      id: listingId,\n      seller: caller.id,\n      itemId: input.itemId,\n      price: input.price,\n      status: 'active',\n      listedAt: Date.now()\n    }))\n\n    await kv.put('listingCount', String(count + 1))\n    return { success: true, listingId }\n  }\n\n  if (input.action === 'buy') {\n    const listing = JSON.parse(await kv.get(input.listingId))\n\n    if (!listing || listing.status !== 'active') {\n      throw new Error('Listing not available')\n    }\n\n    if (listing.seller === caller.id) {\n      throw new Error('Cannot buy your own listing')\n    }\n\n    listing.status = 'sold'\n    listing.buyer = caller.id\n    listing.soldAt = Date.now()\n\n    await kv.put(input.listingId, JSON.stringify(listing))\n    await kv.put(`owner:${listing.itemId}`, caller.id)\n\n    return { success: true, itemId: listing.itemId, price: listing.price }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const listingId = url.searchParams.get('id')\n\n  if (listingId) {\n    const listing = await kv.get(listingId)\n    return listing ? JSON.parse(listing) : null\n  }\n\n  const count = await kv.get('listingCount') || '0'\n  return { listingCount: parseInt(count) }\n}",
    "result": {
      "success": true,
      "itemId": "nft_12345",
      "price": 100
    }
  },
  {
    "id": "message-board",
    "title": "Message Board",
    "description": "Post and read messages publicly",
    "category": "Social",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  await kv.put('messageCount', '0')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  const count = parseInt(await kv.get('messageCount') || '0')\n  const messageId = `msg_${count + 1}`\n\n  await kv.put(messageId, JSON.stringify({\n    id: messageId,\n    author: caller.id,\n    username: caller.username,\n    content: input.message,\n    timestamp: Date.now()\n  }))\n\n  await kv.put('messageCount', String(count + 1))\n\n  return { success: true, messageId, count: count + 1 }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const limit = parseInt(url.searchParams.get('limit') || '20')\n  const count = parseInt(await kv.get('messageCount') || '0')\n\n  const messages = []\n  for (let i = Math.max(1, count - limit + 1); i <= count; i++) {\n    const msg = await kv.get(`msg_${i}`)\n    if (msg) messages.push(JSON.parse(msg))\n  }\n\n  return {\n    messages: messages.reverse(),\n    totalCount: count\n  }\n}",
    "result": {
      "success": true,
      "messageId": "msg_42",
      "count": 42
    }
  },
  {
    "id": "social-graph",
    "title": "Social Graph",
    "description": "Follow and unfollow users, build social connections",
    "category": "Social",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n\n  if (input.action === 'follow') {\n    const following = JSON.parse(await kv.get(`following:${caller.id}`) || '[]')\n    const followers = JSON.parse(await kv.get(`followers:${input.userId}`) || '[]')\n\n    if (following.includes(input.userId)) {\n      throw new Error('Already following')\n    }\n\n    following.push(input.userId)\n    followers.push(caller.id)\n\n    await kv.put(`following:${caller.id}`, JSON.stringify(following))\n    await kv.put(`followers:${input.userId}`, JSON.stringify(followers))\n\n    return { success: true, action: 'followed', userId: input.userId }\n  }\n\n  if (input.action === 'unfollow') {\n    const following = JSON.parse(await kv.get(`following:${caller.id}`) || '[]')\n    const followers = JSON.parse(await kv.get(`followers:${input.userId}`) || '[]')\n\n    const newFollowing = following.filter(id => id !== input.userId)\n    const newFollowers = followers.filter(id => id !== caller.id)\n\n    await kv.put(`following:${caller.id}`, JSON.stringify(newFollowing))\n    await kv.put(`followers:${input.userId}`, JSON.stringify(newFollowers))\n\n    return { success: true, action: 'unfollowed', userId: input.userId }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const userId = url.searchParams.get('userId') || req.tana.caller?.id\n\n  if (!userId) {\n    return { error: 'userId required' }\n  }\n\n  const following = JSON.parse(await kv.get(`following:${userId}`) || '[]')\n  const followers = JSON.parse(await kv.get(`followers:${userId}`) || '[]')\n\n  return {\n    userId,\n    following,\n    followers,\n    followingCount: following.length,\n    followersCount: followers.length\n  }\n}",
    "result": {
      "success": true,
      "action": "followed",
      "userId": "usr_bob"
    }
  },
  {
    "id": "timelock",
    "title": "Timelock",
    "description": "Schedule actions to execute after a delay",
    "category": "Security",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const owner = context.owner()\n  await kv.put('owner', owner.id)\n  await kv.put('lockCount', '0')\n  return { initialized: true }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n  const owner = await kv.get('owner')\n\n  if (caller.id !== owner) {\n    throw new Error('Only owner can use timelock')\n  }\n\n  if (input.action === 'schedule') {\n    const count = parseInt(await kv.get('lockCount') || '0')\n    const lockId = `lock_${count + 1}`\n\n    await kv.put(lockId, JSON.stringify({\n      id: lockId,\n      data: input.data,\n      executeAfter: Date.now() + (input.delaySeconds * 1000),\n      status: 'pending'\n    }))\n\n    await kv.put('lockCount', String(count + 1))\n    return { success: true, lockId, executeAfter: Date.now() + (input.delaySeconds * 1000) }\n  }\n\n  if (input.action === 'execute') {\n    const lock = JSON.parse(await kv.get(input.lockId))\n\n    if (!lock || lock.status !== 'pending') {\n      throw new Error('Invalid or already executed')\n    }\n\n    if (Date.now() < lock.executeAfter) {\n      throw new Error('Timelock not expired')\n    }\n\n    lock.status = 'executed'\n    lock.executedAt = Date.now()\n    await kv.put(input.lockId, JSON.stringify(lock))\n\n    return { success: true, executed: lock.data }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const lockId = url.searchParams.get('id')\n\n  if (lockId) {\n    const lock = await kv.get(lockId)\n    return lock ? JSON.parse(lock) : null\n  }\n\n  const count = await kv.get('lockCount') || '0'\n  return { lockCount: parseInt(count) }\n}",
    "result": {
      "success": true,
      "lockId": "lock_5",
      "executeAfter": 1699651200000
    }
  },
  {
    "id": "multisig-wallet",
    "title": "Multisig Wallet",
    "description": "Require multiple signatures for actions",
    "category": "Security",
    "code": "import { kv } from 'tana/kv'\nimport { context } from 'tana/context'\nimport type { Request } from 'tana/net'\n\nexport async function init() {\n  const input = context.input()\n\n  await kv.put('signers', JSON.stringify(input.signers))\n  await kv.put('threshold', String(input.threshold))\n  await kv.put('proposalCount', '0')\n\n  return { initialized: true, signers: input.signers, threshold: input.threshold }\n}\n\nexport async function contract() {\n  const input = context.input()\n  const caller = context.caller()\n  const signers = JSON.parse(await kv.get('signers') || '[]')\n\n  if (!signers.includes(caller.id)) {\n    throw new Error('Not a signer')\n  }\n\n  if (input.action === 'propose') {\n    const count = parseInt(await kv.get('proposalCount') || '0')\n    const proposalId = `proposal_${count + 1}`\n\n    await kv.put(proposalId, JSON.stringify({\n      id: proposalId,\n      data: input.data,\n      signatures: [caller.id],\n      status: 'pending',\n      created: Date.now()\n    }))\n\n    await kv.put('proposalCount', String(count + 1))\n    return { success: true, proposalId }\n  }\n\n  if (input.action === 'sign') {\n    const proposal = JSON.parse(await kv.get(input.proposalId))\n    const threshold = parseInt(await kv.get('threshold'))\n\n    if (proposal.signatures.includes(caller.id)) {\n      throw new Error('Already signed')\n    }\n\n    proposal.signatures.push(caller.id)\n\n    if (proposal.signatures.length >= threshold) {\n      proposal.status = 'executed'\n      proposal.executedAt = Date.now()\n    }\n\n    await kv.put(input.proposalId, JSON.stringify(proposal))\n\n    return {\n      success: true,\n      proposalId: input.proposalId,\n      signatures: proposal.signatures.length,\n      threshold,\n      executed: proposal.status === 'executed'\n    }\n  }\n}\n\nexport async function get(req: Request) {\n  const url = new URL(req.url)\n  const proposalId = url.searchParams.get('id')\n\n  if (proposalId) {\n    const proposal = await kv.get(proposalId)\n    return proposal ? JSON.parse(proposal) : null\n  }\n\n  return {\n    signers: JSON.parse(await kv.get('signers') || '[]'),\n    threshold: parseInt(await kv.get('threshold') || '0'),\n    proposalCount: parseInt(await kv.get('proposalCount') || '0')\n  }\n}",
    "result": {
      "success": true,
      "proposalId": "proposal_3",
      "signatures": 2,
      "threshold": 3,
      "executed": false
    }
  }
]